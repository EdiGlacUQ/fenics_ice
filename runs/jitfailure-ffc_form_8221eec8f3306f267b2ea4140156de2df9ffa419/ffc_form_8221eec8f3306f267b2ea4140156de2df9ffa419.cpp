// This code conforms with the UFC specification version 2017.1.0
// and was automatically generated by FFC version 2017.1.0.
// 
// This code was generated with the following parameters:
// 
//   add_tabulate_tensor_timing:     False
//   convert_exceptions_to_warnings: False
//   cpp_optimize:                   True
//   cpp_optimize_flags:             '-O2 -ffast-math -march=native'
//   epsilon:                        1e-14
//   error_control:                  False
//   form_postfix:                   False
//   format:                         'ufc'
//   generate_dummy_tabulate_tensor: False
//   max_signature_length:           0
//   no-evaluate_basis_derivatives:  True
//   optimize:                       True
//   precision:                      None
//   quadrature_degree:              None
//   quadrature_rule:                None
//   representation:                 'auto'
//   split:                          False

#include "ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419.h"

// Based on https://gcc.gnu.org/wiki/Visibility
#if defined _WIN32 || defined __CYGWIN__
    #ifdef __GNUC__
        #define DLL_EXPORT __attribute__ ((dllexport))
    #else
        #define DLL_EXPORT __declspec(dllexport)
    #endif
#else
    #define DLL_EXPORT __attribute__ ((visibility ("default")))
#endif

ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_cell_integral_main_1::ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_cell_integral_main_1() : ufc::cell_integral()
{

}

ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_cell_integral_main_1::~ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_cell_integral_main_1()
{

}

const std::vector<bool> & ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_cell_integral_main_1::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true, true, true, true});
return enabled;
}

void ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_cell_integral_main_1::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    //   num_cells:         None
    //   optimize:          True
    //   precision:         16
    //   quadrature_degree: 7
    //   quadrature_rule:   'default'
    //   representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    //   estimated_polynomial_degree: 7
    //   optimize:                    True
    //   precision:                   16
    //   quadrature_degree:           7
    //   quadrature_rule:             'default'
    //   representation:              'uflacs'
    
    // Quadrature rules
    alignas(32) static const double weights16[16] = { 0.02356836819338231, 0.03538806789808593, 0.02258404928236992, 0.00542322591052525, 0.04418508852236171, 0.06634421610704974, 0.0423397245217463, 0.01016725956447878, 0.04418508852236171, 0.06634421610704974, 0.0423397245217463, 0.01016725956447878, 0.02356836819338231, 0.03538806789808593, 0.02258404928236992, 0.00542322591052525 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE15_C0_D01_Q16[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double FE15_C0_Q16[1][16][3] =
        { { { 0.877428809330468, 0.06546699455501447, 0.05710419611451763 },
            { 0.6729468631505066, 0.05021012321136976, 0.2768430136381238 },
            { 0.3874974834066942, 0.02891208422438899, 0.5835904323689167 },
            { 0.1300560792168344, 0.009703785126946193, 0.8602401356562195 },
            { 0.6317312516411253, 0.3111645522443571, 0.05710419611451763 },
            { 0.4845083266304333, 0.2386486597314429, 0.2768430136381237 },
            { 0.2789904634965088, 0.1374191041345744, 0.5835904323689167 },
            { 0.09363778443732851, 0.04612207990645211, 0.8602401356562195 },
            { 0.3111645522443571, 0.6317312516411253, 0.05710419611451763 },
            { 0.238648659731443, 0.4845083266304333, 0.2768430136381238 },
            { 0.1374191041345744, 0.2789904634965088, 0.5835904323689167 },
            { 0.04612207990645206, 0.09363778443732856, 0.8602401356562195 },
            { 0.06546699455501447, 0.877428809330468, 0.05710419611451763 },
            { 0.05021012321136983, 0.6729468631505063, 0.2768430136381237 },
            { 0.02891208422438899, 0.3874974834066942, 0.5835904323689167 },
            { 0.009703785126946082, 0.1300560792168345, 0.8602401356562195 } } };
    // Unstructured piecewise computations
    const double w1_d1 = w[1][0] * FE15_C0_D01_Q16[0][0][0] + w[1][2] * FE15_C0_D01_Q16[0][0][1];
    const double J_c0 = coordinate_dofs[0] * FE15_C0_D01_Q16[0][0][0] + coordinate_dofs[2] * FE15_C0_D01_Q16[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE15_C0_D01_Q16[0][0][0] + coordinate_dofs[5] * FE15_C0_D01_Q16[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE15_C0_D01_Q16[0][0][0] + coordinate_dofs[4] * FE15_C0_D01_Q16[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE15_C0_D01_Q16[0][0][0] + coordinate_dofs[3] * FE15_C0_D01_Q16[0][0][1];
    double w1_d0 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w1_d0 += w[1][ic] * FE15_C0_D01_Q16[0][0][ic];
    const double w2_d1 = w[2][0] * FE15_C0_D01_Q16[0][0][0] + w[2][2] * FE15_C0_D01_Q16[0][0][1];
    double w2_d0 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w2_d0 += w[2][ic] * FE15_C0_D01_Q16[0][0][ic];
    const double w0_d1_c1 = w[0][3] * FE15_C0_D01_Q16[0][0][0] + w[0][5] * FE15_C0_D01_Q16[0][0][1];
    double w0_d0_c1 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c1 += w[0][ic + 3] * FE15_C0_D01_Q16[0][0][ic];
    double w0_d0_c0 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c0 += w[0][ic] * FE15_C0_D01_Q16[0][0][ic];
    const double w0_d1_c0 = w[0][0] * FE15_C0_D01_Q16[0][0][0] + w[0][2] * FE15_C0_D01_Q16[0][0][1];
    alignas(32) double sp[67];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = J_c0 / sp[2];
    sp[4] = w1_d1 * sp[3];
    sp[5] = -1 * J_c1 / sp[2];
    sp[6] = w1_d0 * sp[5];
    sp[7] = sp[4] + sp[6];
    sp[8] = w2_d1 * sp[3];
    sp[9] = w2_d0 * sp[5];
    sp[10] = sp[8] + sp[9];
    sp[11] = J_c3 / sp[2];
    sp[12] = w1_d0 * sp[11];
    sp[13] = -1 * J_c2 / sp[2];
    sp[14] = w1_d1 * sp[13];
    sp[15] = sp[12] + sp[14];
    sp[16] = w2_d0 * sp[11];
    sp[17] = w2_d1 * sp[13];
    sp[18] = sp[16] + sp[17];
    sp[19] = sp[3] + sp[3];
    sp[20] = sp[5] + sp[5];
    sp[21] = w0_d1_c1 * sp[3];
    sp[22] = w0_d0_c1 * sp[5];
    sp[23] = sp[21] + sp[22];
    sp[24] = sp[23] + sp[23];
    sp[25] = 2 * (sp[19] / 2) * (sp[24] / 2);
    sp[26] = 2 * (sp[20] / 2) * (sp[24] / 2);
    sp[27] = sp[11] + sp[11];
    sp[28] = sp[13] + sp[13];
    sp[29] = w0_d0_c0 * sp[11];
    sp[30] = w0_d1_c0 * sp[13];
    sp[31] = sp[29] + sp[30];
    sp[32] = sp[31] + sp[31];
    sp[33] = 2 * (sp[27] / 2) * (sp[32] / 2);
    sp[34] = 2 * (sp[28] / 2) * (sp[32] / 2);
    sp[35] = sp[24] / 2 * (sp[27] / 2);
    sp[36] = sp[24] / 2 * (sp[28] / 2);
    sp[37] = sp[32] / 2 * (sp[19] / 2);
    sp[38] = sp[32] / 2 * (sp[20] / 2);
    sp[39] = sp[25] + sp[37];
    sp[40] = sp[26] + sp[38];
    sp[41] = sp[33] + sp[35];
    sp[42] = sp[34] + sp[36];
    sp[43] = w0_d1_c0 * sp[3];
    sp[44] = w0_d0_c0 * sp[5];
    sp[45] = sp[43] + sp[44];
    sp[46] = w0_d0_c1 * sp[11];
    sp[47] = w0_d1_c1 * sp[13];
    sp[48] = sp[46] + sp[47];
    sp[49] = sp[45] + sp[48];
    sp[50] = 2 * (sp[13] / 2) * (sp[49] / 2);
    sp[51] = 2 * (sp[11] / 2) * (sp[49] / 2);
    sp[52] = 2 * (sp[5] / 2) * (sp[49] / 2);
    sp[53] = 2 * (sp[3] / 2) * (sp[49] / 2);
    sp[54] = sp[39] + sp[50];
    sp[55] = sp[40] + sp[51];
    sp[56] = sp[41] + sp[52];
    sp[57] = sp[42] + sp[53];
    sp[58] = std::pow(sp[24] / 2, 2) + std::pow(sp[32] / 2, 2);
    sp[59] = sp[24] / 2 * (sp[32] / 2);
    sp[60] = sp[58] + sp[59];
    sp[61] = sp[60] + std::pow(sp[49] / 2, 2);
    sp[62] = 0.6666666666666666 * sp[54] * std::pow(1e-10 + sp[61], -0.3333333333333334);
    sp[63] = 0.6666666666666666 * sp[55] * std::pow(1e-10 + sp[61], -0.3333333333333334);
    sp[64] = 0.6666666666666666 * sp[56] * std::pow(1e-10 + sp[61], -0.3333333333333334);
    sp[65] = 0.6666666666666666 * sp[57] * std::pow(1e-10 + sp[61], -0.3333333333333334);
    sp[66] = std::abs(sp[2]);
    alignas(32) double BF0[2] = {};
    alignas(32) double BF1[3] = {};
    alignas(32) double BF2[2] = {};
    alignas(32) double BF3[2] = {};
    alignas(32) double BF4[3] = {};
    alignas(32) double BF5[2] = {};
    for (int iq = 0; iq < 16; ++iq)
    {
        // Quadrature loop body setup (num_points=16)
        // Unstructured varying computations for num_points=16
        double w2 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w2 += w[2][ic] * FE15_C0_Q16[0][iq][ic];
        double w1 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w1 += w[1][ic] * FE15_C0_Q16[0][iq][ic];
        double w0_c0 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c0 += w[0][ic] * FE15_C0_Q16[0][iq][ic];
        double w0_c1 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c1 += w[0][ic + 3] * FE15_C0_Q16[0][iq][ic];
        double w3 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w3 += w[3][ic] * FE15_C0_Q16[0][iq][ic];
        double w4 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w4 += w[4][ic] * FE15_C0_Q16[0][iq][ic];
        alignas(32) double sv16[48];
        sv16[0] = (w2 > -1.09051254089422 * w1 ? 8995.77 * w2 : 8995.77 * (-1.09051254089422 * w1));
        sv16[1] = sp[7] * sv16[0];
        sv16[2] = 2 * sp[10] * w2;
        sv16[3] = 2 * (-1.09051254089422 * sp[7]) * (-1.09051254089422 * w1);
        sv16[4] = 0.917 * sv16[3] + 0.08299999999999996 * sv16[2];
        sv16[5] = (w2 > -1.09051254089422 * w1 ? 4497.885 * sv16[2] : 4497.885 * sv16[4]);
        sv16[6] = sv16[1] + sv16[5];
        sv16[7] = sp[15] * sv16[0];
        sv16[8] = 2 * sp[18] * w2;
        sv16[9] = 2 * (-1.09051254089422 * sp[15]) * (-1.09051254089422 * w1);
        sv16[10] = 0.917 * sv16[9] + 0.08299999999999996 * sv16[8];
        sv16[11] = (w2 > -1.09051254089422 * w1 ? 4497.885 * sv16[8] : 4497.885 * sv16[10]);
        sv16[12] = sv16[7] + sv16[11];
        sv16[13] = 323165.2035047823 * sp[62] * w2;
        sv16[14] = 323165.2035047823 * sp[63] * w2;
        sv16[15] = 323165.2035047823 * sp[64] * w2;
        sv16[16] = 323165.2035047823 * sp[65] * w2;
        sv16[17] = w0_c0 + w0_c0;
        sv16[18] = w0_c1 + w0_c1;
        sv16[19] = 9.81 * (917.0 * (1.0 + -1 * (w2 <= -1.09051254089422 * w1 ? 1.0 : 0.0))) * w2;
        sv16[20] = sp[7] * (1.0 + -1 * (w2 <= -1.09051254089422 * w1 ? 1.0 : 0.0));
        sv16[21] = sp[10] * (-0.917 * (w2 <= -1.09051254089422 * w1 ? 1.0 : 0.0));
        sv16[22] = sv16[20] + sv16[21];
        sv16[23] = sv16[22] + sp[10];
        sv16[24] = sp[15] * (1.0 + -1 * (w2 <= -1.09051254089422 * w1 ? 1.0 : 0.0));
        sv16[25] = sp[18] * (-0.917 * (w2 <= -1.09051254089422 * w1 ? 1.0 : 0.0));
        sv16[26] = sv16[24] + sv16[25];
        sv16[27] = sv16[26] + sp[18];
        sv16[28] = std::pow(sv16[23], 2.0) + std::pow(sv16[27], 2.0);
        sv16[29] = sv16[19] * std::pow(sv16[28], 0.5);
        sv16[30] = std::pow(w3, 2) + std::pow(w4, 2);
        sv16[31] = sv16[29] / std::max(std::pow(sv16[30], 0.5), 5.0);
        sv16[32] = 2000.0 * (w2 <= -1.09051254089422 * w1 ? 1.0 : 0.0) + sv16[31];
        sv16[33] = sv16[32] * (w2 > 0.0 ? 1.0 : 0.0);
        sv16[34] = 2000.0 * (1.0 + -1 * (w2 > 0.0 ? 1.0 : 0.0)) + sv16[33];
        sv16[35] = std::log(std::min(std::max(sv16[34], 1), 10000.0));
        sv16[36] = std::exp(sv16[35]);
        sv16[37] = 0.5 * (1.0 + -1 * (w2 <= -1.09051254089422 * w1 ? 1.0 : 0.0)) * sv16[36];
        sv16[38] = sv16[18] * sv16[37];
        sv16[39] = sv16[17] * sv16[37];
        sv16[40] = sv16[6] + sv16[38];
        sv16[41] = sv16[12] + sv16[39];
        sv16[42] = sv16[40] * sp[66];
        sv16[43] = sv16[41] * sp[66];
        sv16[44] = sv16[13] * sp[66];
        sv16[45] = sv16[14] * sp[66];
        sv16[46] = sv16[15] * sp[66];
        sv16[47] = sv16[16] * sp[66];
        const double fw0 = sv16[46] * weights16[iq];
        for (int i = 0; i < 2; ++i)
            BF0[i] += fw0 * FE15_C0_D01_Q16[0][0][i];
        const double fw1 = sv16[43] * weights16[iq];
        for (int i = 0; i < 3; ++i)
            BF1[i] += fw1 * FE15_C0_Q16[0][iq][i];
        const double fw2 = sv16[47] * weights16[iq];
        for (int i = 0; i < 2; ++i)
            BF2[i] += fw2 * FE15_C0_D01_Q16[0][0][i];
        const double fw3 = sv16[45] * weights16[iq];
        for (int i = 0; i < 2; ++i)
            BF3[i] += fw3 * FE15_C0_D01_Q16[0][0][i];
        const double fw4 = sv16[42] * weights16[iq];
        for (int i = 0; i < 3; ++i)
            BF4[i] += fw4 * FE15_C0_Q16[0][iq][i];
        const double fw5 = sv16[44] * weights16[iq];
        for (int i = 0; i < 2; ++i)
            BF5[i] += fw5 * FE15_C0_D01_Q16[0][0][i];
    }
    std::fill(&A[0], &A[6], 0.0);
    static const int DM0[2] = { 0, 2 };
    static const int DM1[2] = { 3, 5 };
    for (int i = 0; i < 2; ++i)
        A[i] += BF0[i];
    for (int i = 0; i < 3; ++i)
        A[i] += BF1[i];
    for (int i = 0; i < 2; ++i)
        A[DM0[i]] += BF2[i];
    for (int i = 0; i < 2; ++i)
        A[i + 3] += BF3[i];
    for (int i = 0; i < 3; ++i)
        A[i + 3] += BF4[i];
    for (int i = 0; i < 2; ++i)
        A[DM1[i]] += BF5[i];
}

extern "C" DLL_EXPORT ufc::cell_integral * create_ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_cell_integral_main_1()
{
  return new ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_cell_integral_main_1();
}


ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_cell_integral_main_2::ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_cell_integral_main_2() : ufc::cell_integral()
{

}

ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_cell_integral_main_2::~ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_cell_integral_main_2()
{

}

const std::vector<bool> & ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_cell_integral_main_2::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true, true, true, true});
return enabled;
}

void ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_cell_integral_main_2::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    //   num_cells:         None
    //   optimize:          True
    //   precision:         16
    //   quadrature_degree: 7
    //   quadrature_rule:   'default'
    //   representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    //   estimated_polynomial_degree: 7
    //   optimize:                    True
    //   precision:                   16
    //   quadrature_degree:           7
    //   quadrature_rule:             'default'
    //   representation:              'uflacs'
    
    // Quadrature rules
    alignas(32) static const double weights16[16] = { 0.02356836819338231, 0.03538806789808593, 0.02258404928236992, 0.00542322591052525, 0.04418508852236171, 0.06634421610704974, 0.0423397245217463, 0.01016725956447878, 0.04418508852236171, 0.06634421610704974, 0.0423397245217463, 0.01016725956447878, 0.02356836819338231, 0.03538806789808593, 0.02258404928236992, 0.00542322591052525 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE15_C0_D01_Q16[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double FE15_C0_Q16[1][16][3] =
        { { { 0.877428809330468, 0.06546699455501447, 0.05710419611451763 },
            { 0.6729468631505066, 0.05021012321136976, 0.2768430136381238 },
            { 0.3874974834066942, 0.02891208422438899, 0.5835904323689167 },
            { 0.1300560792168344, 0.009703785126946193, 0.8602401356562195 },
            { 0.6317312516411253, 0.3111645522443571, 0.05710419611451763 },
            { 0.4845083266304333, 0.2386486597314429, 0.2768430136381237 },
            { 0.2789904634965088, 0.1374191041345744, 0.5835904323689167 },
            { 0.09363778443732851, 0.04612207990645211, 0.8602401356562195 },
            { 0.3111645522443571, 0.6317312516411253, 0.05710419611451763 },
            { 0.238648659731443, 0.4845083266304333, 0.2768430136381238 },
            { 0.1374191041345744, 0.2789904634965088, 0.5835904323689167 },
            { 0.04612207990645206, 0.09363778443732856, 0.8602401356562195 },
            { 0.06546699455501447, 0.877428809330468, 0.05710419611451763 },
            { 0.05021012321136983, 0.6729468631505063, 0.2768430136381237 },
            { 0.02891208422438899, 0.3874974834066942, 0.5835904323689167 },
            { 0.009703785126946082, 0.1300560792168345, 0.8602401356562195 } } };
    // Unstructured piecewise computations
    const double w1_d1 = w[1][0] * FE15_C0_D01_Q16[0][0][0] + w[1][2] * FE15_C0_D01_Q16[0][0][1];
    const double J_c0 = coordinate_dofs[0] * FE15_C0_D01_Q16[0][0][0] + coordinate_dofs[2] * FE15_C0_D01_Q16[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE15_C0_D01_Q16[0][0][0] + coordinate_dofs[5] * FE15_C0_D01_Q16[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE15_C0_D01_Q16[0][0][0] + coordinate_dofs[4] * FE15_C0_D01_Q16[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE15_C0_D01_Q16[0][0][0] + coordinate_dofs[3] * FE15_C0_D01_Q16[0][0][1];
    double w1_d0 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w1_d0 += w[1][ic] * FE15_C0_D01_Q16[0][0][ic];
    const double w2_d1 = w[2][0] * FE15_C0_D01_Q16[0][0][0] + w[2][2] * FE15_C0_D01_Q16[0][0][1];
    double w2_d0 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w2_d0 += w[2][ic] * FE15_C0_D01_Q16[0][0][ic];
    const double w0_d1_c1 = w[0][3] * FE15_C0_D01_Q16[0][0][0] + w[0][5] * FE15_C0_D01_Q16[0][0][1];
    double w0_d0_c1 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c1 += w[0][ic + 3] * FE15_C0_D01_Q16[0][0][ic];
    double w0_d0_c0 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c0 += w[0][ic] * FE15_C0_D01_Q16[0][0][ic];
    const double w0_d1_c0 = w[0][0] * FE15_C0_D01_Q16[0][0][0] + w[0][2] * FE15_C0_D01_Q16[0][0][1];
    alignas(32) double sp[67];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = J_c0 / sp[2];
    sp[4] = w1_d1 * sp[3];
    sp[5] = -1 * J_c1 / sp[2];
    sp[6] = w1_d0 * sp[5];
    sp[7] = sp[4] + sp[6];
    sp[8] = w2_d1 * sp[3];
    sp[9] = w2_d0 * sp[5];
    sp[10] = sp[8] + sp[9];
    sp[11] = J_c3 / sp[2];
    sp[12] = w1_d0 * sp[11];
    sp[13] = -1 * J_c2 / sp[2];
    sp[14] = w1_d1 * sp[13];
    sp[15] = sp[12] + sp[14];
    sp[16] = w2_d0 * sp[11];
    sp[17] = w2_d1 * sp[13];
    sp[18] = sp[16] + sp[17];
    sp[19] = sp[3] + sp[3];
    sp[20] = sp[5] + sp[5];
    sp[21] = w0_d1_c1 * sp[3];
    sp[22] = w0_d0_c1 * sp[5];
    sp[23] = sp[21] + sp[22];
    sp[24] = sp[23] + sp[23];
    sp[25] = 2 * (sp[19] / 2) * (sp[24] / 2);
    sp[26] = 2 * (sp[20] / 2) * (sp[24] / 2);
    sp[27] = sp[11] + sp[11];
    sp[28] = sp[13] + sp[13];
    sp[29] = w0_d0_c0 * sp[11];
    sp[30] = w0_d1_c0 * sp[13];
    sp[31] = sp[29] + sp[30];
    sp[32] = sp[31] + sp[31];
    sp[33] = 2 * (sp[27] / 2) * (sp[32] / 2);
    sp[34] = 2 * (sp[28] / 2) * (sp[32] / 2);
    sp[35] = sp[24] / 2 * (sp[27] / 2);
    sp[36] = sp[24] / 2 * (sp[28] / 2);
    sp[37] = sp[32] / 2 * (sp[19] / 2);
    sp[38] = sp[32] / 2 * (sp[20] / 2);
    sp[39] = sp[25] + sp[37];
    sp[40] = sp[26] + sp[38];
    sp[41] = sp[33] + sp[35];
    sp[42] = sp[34] + sp[36];
    sp[43] = w0_d1_c0 * sp[3];
    sp[44] = w0_d0_c0 * sp[5];
    sp[45] = sp[43] + sp[44];
    sp[46] = w0_d0_c1 * sp[11];
    sp[47] = w0_d1_c1 * sp[13];
    sp[48] = sp[46] + sp[47];
    sp[49] = sp[45] + sp[48];
    sp[50] = 2 * (sp[13] / 2) * (sp[49] / 2);
    sp[51] = 2 * (sp[11] / 2) * (sp[49] / 2);
    sp[52] = 2 * (sp[5] / 2) * (sp[49] / 2);
    sp[53] = 2 * (sp[3] / 2) * (sp[49] / 2);
    sp[54] = sp[39] + sp[50];
    sp[55] = sp[40] + sp[51];
    sp[56] = sp[41] + sp[52];
    sp[57] = sp[42] + sp[53];
    sp[58] = std::pow(sp[24] / 2, 2) + std::pow(sp[32] / 2, 2);
    sp[59] = sp[24] / 2 * (sp[32] / 2);
    sp[60] = sp[58] + sp[59];
    sp[61] = sp[60] + std::pow(sp[49] / 2, 2);
    sp[62] = 0.6666666666666666 * sp[54] * std::pow(1e-10 + sp[61], -0.3333333333333334);
    sp[63] = 0.6666666666666666 * sp[55] * std::pow(1e-10 + sp[61], -0.3333333333333334);
    sp[64] = 0.6666666666666666 * sp[56] * std::pow(1e-10 + sp[61], -0.3333333333333334);
    sp[65] = 0.6666666666666666 * sp[57] * std::pow(1e-10 + sp[61], -0.3333333333333334);
    sp[66] = std::abs(sp[2]);
    alignas(32) double BF0[2] = {};
    alignas(32) double BF1[3] = {};
    alignas(32) double BF2[2] = {};
    alignas(32) double BF3[2] = {};
    alignas(32) double BF4[3] = {};
    alignas(32) double BF5[2] = {};
    for (int iq = 0; iq < 16; ++iq)
    {
        // Quadrature loop body setup (num_points=16)
        // Unstructured varying computations for num_points=16
        double w2 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w2 += w[2][ic] * FE15_C0_Q16[0][iq][ic];
        double w1 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w1 += w[1][ic] * FE15_C0_Q16[0][iq][ic];
        double w0_c0 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c0 += w[0][ic] * FE15_C0_Q16[0][iq][ic];
        double w0_c1 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c1 += w[0][ic + 3] * FE15_C0_Q16[0][iq][ic];
        double w3 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w3 += w[3][ic] * FE15_C0_Q16[0][iq][ic];
        double w4 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w4 += w[4][ic] * FE15_C0_Q16[0][iq][ic];
        alignas(32) double sv16[48];
        sv16[0] = (w2 > -1.09051254089422 * w1 ? 8995.77 * w2 : 8995.77 * (-1.09051254089422 * w1));
        sv16[1] = sp[7] * sv16[0];
        sv16[2] = 2 * sp[10] * w2;
        sv16[3] = 2 * (-1.09051254089422 * sp[7]) * (-1.09051254089422 * w1);
        sv16[4] = 0.917 * sv16[3] + 0.08299999999999996 * sv16[2];
        sv16[5] = (w2 > -1.09051254089422 * w1 ? 4497.885 * sv16[2] : 4497.885 * sv16[4]);
        sv16[6] = sv16[1] + sv16[5];
        sv16[7] = sp[15] * sv16[0];
        sv16[8] = 2 * sp[18] * w2;
        sv16[9] = 2 * (-1.09051254089422 * sp[15]) * (-1.09051254089422 * w1);
        sv16[10] = 0.917 * sv16[9] + 0.08299999999999996 * sv16[8];
        sv16[11] = (w2 > -1.09051254089422 * w1 ? 4497.885 * sv16[8] : 4497.885 * sv16[10]);
        sv16[12] = sv16[7] + sv16[11];
        sv16[13] = 323165.2035047823 * sp[62] * w2;
        sv16[14] = 323165.2035047823 * sp[63] * w2;
        sv16[15] = 323165.2035047823 * sp[64] * w2;
        sv16[16] = 323165.2035047823 * sp[65] * w2;
        sv16[17] = w0_c0 + w0_c0;
        sv16[18] = w0_c1 + w0_c1;
        sv16[19] = 9.81 * (917.0 * (1.0 + -1 * (w2 <= -1.09051254089422 * w1 ? 1.0 : 0.0))) * w2;
        sv16[20] = sp[7] * (1.0 + -1 * (w2 <= -1.09051254089422 * w1 ? 1.0 : 0.0));
        sv16[21] = sp[10] * (-0.917 * (w2 <= -1.09051254089422 * w1 ? 1.0 : 0.0));
        sv16[22] = sv16[20] + sv16[21];
        sv16[23] = sv16[22] + sp[10];
        sv16[24] = sp[15] * (1.0 + -1 * (w2 <= -1.09051254089422 * w1 ? 1.0 : 0.0));
        sv16[25] = sp[18] * (-0.917 * (w2 <= -1.09051254089422 * w1 ? 1.0 : 0.0));
        sv16[26] = sv16[24] + sv16[25];
        sv16[27] = sv16[26] + sp[18];
        sv16[28] = std::pow(sv16[23], 2.0) + std::pow(sv16[27], 2.0);
        sv16[29] = sv16[19] * std::pow(sv16[28], 0.5);
        sv16[30] = std::pow(w3, 2) + std::pow(w4, 2);
        sv16[31] = sv16[29] / std::max(std::pow(sv16[30], 0.5), 5.0);
        sv16[32] = 2000.0 * (w2 <= -1.09051254089422 * w1 ? 1.0 : 0.0) + sv16[31];
        sv16[33] = sv16[32] * (w2 > 0.0 ? 1.0 : 0.0);
        sv16[34] = 2000.0 * (1.0 + -1 * (w2 > 0.0 ? 1.0 : 0.0)) + sv16[33];
        sv16[35] = std::log(std::min(std::max(sv16[34], 1), 10000.0));
        sv16[36] = std::exp(sv16[35]);
        sv16[37] = 0.5 * (1.0 + -1 * (w2 <= -1.09051254089422 * w1 ? 1.0 : 0.0)) * sv16[36];
        sv16[38] = sv16[18] * sv16[37];
        sv16[39] = sv16[17] * sv16[37];
        sv16[40] = sv16[6] + sv16[38];
        sv16[41] = sv16[12] + sv16[39];
        sv16[42] = sv16[40] * sp[66];
        sv16[43] = sv16[41] * sp[66];
        sv16[44] = sv16[13] * sp[66];
        sv16[45] = sv16[14] * sp[66];
        sv16[46] = sv16[15] * sp[66];
        sv16[47] = sv16[16] * sp[66];
        const double fw0 = sv16[46] * weights16[iq];
        for (int i = 0; i < 2; ++i)
            BF0[i] += fw0 * FE15_C0_D01_Q16[0][0][i];
        const double fw1 = sv16[43] * weights16[iq];
        for (int i = 0; i < 3; ++i)
            BF1[i] += fw1 * FE15_C0_Q16[0][iq][i];
        const double fw2 = sv16[47] * weights16[iq];
        for (int i = 0; i < 2; ++i)
            BF2[i] += fw2 * FE15_C0_D01_Q16[0][0][i];
        const double fw3 = sv16[45] * weights16[iq];
        for (int i = 0; i < 2; ++i)
            BF3[i] += fw3 * FE15_C0_D01_Q16[0][0][i];
        const double fw4 = sv16[42] * weights16[iq];
        for (int i = 0; i < 3; ++i)
            BF4[i] += fw4 * FE15_C0_Q16[0][iq][i];
        const double fw5 = sv16[44] * weights16[iq];
        for (int i = 0; i < 2; ++i)
            BF5[i] += fw5 * FE15_C0_D01_Q16[0][0][i];
    }
    std::fill(&A[0], &A[6], 0.0);
    static const int DM0[2] = { 0, 2 };
    static const int DM1[2] = { 3, 5 };
    for (int i = 0; i < 2; ++i)
        A[i] += BF0[i];
    for (int i = 0; i < 3; ++i)
        A[i] += BF1[i];
    for (int i = 0; i < 2; ++i)
        A[DM0[i]] += BF2[i];
    for (int i = 0; i < 2; ++i)
        A[i + 3] += BF3[i];
    for (int i = 0; i < 3; ++i)
        A[i + 3] += BF4[i];
    for (int i = 0; i < 2; ++i)
        A[DM1[i]] += BF5[i];
}

extern "C" DLL_EXPORT ufc::cell_integral * create_ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_cell_integral_main_2()
{
  return new ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_cell_integral_main_2();
}


ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_interior_facet_integral_main_otherwise::ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_interior_facet_integral_main_otherwise() : ufc::interior_facet_integral()
{

}

ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_interior_facet_integral_main_otherwise::~ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_interior_facet_integral_main_otherwise()
{

}

const std::vector<bool> & ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_interior_facet_integral_main_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({false, true, true, false, false});
return enabled;
}

void ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_interior_facet_integral_main_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs_0,
                                    const double * coordinate_dofs_1,
                                    std::size_t facet_0,
                                    std::size_t facet_1,
                                    int cell_orientation_0,
                                    int cell_orientation_1) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    //   num_cells:         None
    //   optimize:          True
    //   precision:         16
    //   quadrature_degree: 3
    //   quadrature_rule:   'default'
    //   representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    //   estimated_polynomial_degree: 3
    //   optimize:                    True
    //   precision:                   16
    //   quadrature_degree:           3
    //   quadrature_rule:             'default'
    //   representation:              'uflacs'
    
    // Quadrature rules
    alignas(32) static const double weights2[2] = { 0.5, 0.5 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE5_C0_D01_F_Q2[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double FE5_C0_F_Q2[3][2][3] =
        { { { 0.0, 0.7886751345948129, 0.2113248654051871 },
            { 0.0, 0.2113248654051872, 0.7886751345948129 } },
          { { 0.7886751345948129, 0.0, 0.2113248654051871 },
            { 0.2113248654051872, 0.0, 0.7886751345948129 } },
          { { 0.7886751345948129, 0.2113248654051871, 0.0 },
            { 0.2113248654051871, 0.7886751345948129, 0.0 } } };
    // Unstructured piecewise computations
    const double J_r0_c0 = coordinate_dofs_0[0] * FE5_C0_D01_F_Q2[0][0][0] + coordinate_dofs_0[2] * FE5_C0_D01_F_Q2[0][0][1];
    const double J_r0_c3 = coordinate_dofs_0[1] * FE5_C0_D01_F_Q2[0][0][0] + coordinate_dofs_0[5] * FE5_C0_D01_F_Q2[0][0][1];
    const double J_r0_c1 = coordinate_dofs_0[0] * FE5_C0_D01_F_Q2[0][0][0] + coordinate_dofs_0[4] * FE5_C0_D01_F_Q2[0][0][1];
    const double J_r0_c2 = coordinate_dofs_0[1] * FE5_C0_D01_F_Q2[0][0][0] + coordinate_dofs_0[3] * FE5_C0_D01_F_Q2[0][0][1];
    alignas(32) double sp[29];
    sp[0] = J_r0_c0 * J_r0_c3;
    sp[1] = J_r0_c1 * J_r0_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = J_r0_c0 / sp[2];
    sp[4] = triangle_reference_facet_normals[facet_0][1] * sp[3];
    sp[5] = -1 * J_r0_c1 / sp[2];
    sp[6] = triangle_reference_facet_normals[facet_0][0] * sp[5];
    sp[7] = sp[4] + sp[6];
    sp[8] = sp[7] * sp[7];
    sp[9] = J_r0_c3 / sp[2];
    sp[10] = triangle_reference_facet_normals[facet_0][0] * sp[9];
    sp[11] = -1 * J_r0_c2 / sp[2];
    sp[12] = triangle_reference_facet_normals[facet_0][1] * sp[11];
    sp[13] = sp[10] + sp[12];
    sp[14] = sp[13] * sp[13];
    sp[15] = sp[8] + sp[14];
    sp[16] = std::sqrt(sp[15]);
    sp[17] = sp[7] / sp[16];
    sp[18] = sp[13] / sp[16];
    sp[19] = J_r0_c0 * triangle_reference_facet_jacobian[facet_0][0][0];
    sp[20] = J_r0_c1 * triangle_reference_facet_jacobian[facet_0][1][0];
    sp[21] = sp[19] + sp[20];
    sp[22] = sp[21] * sp[21];
    sp[23] = triangle_reference_facet_jacobian[facet_0][0][0] * J_r0_c2;
    sp[24] = triangle_reference_facet_jacobian[facet_0][1][0] * J_r0_c3;
    sp[25] = sp[23] + sp[24];
    sp[26] = sp[25] * sp[25];
    sp[27] = sp[22] + sp[26];
    sp[28] = std::sqrt(sp[27]);
    alignas(32) double BF0[3] = {};
    alignas(32) double BF1[3] = {};
    for (int iq = 0; iq < 2; ++iq)
    {
        // Quadrature loop body setup (num_points=2)
        // Unstructured varying computations for num_points=2
        double w2_r0 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w2_r0 += w[2][ic] * FE5_C0_F_Q2[facet_0][iq][ic];
        double w1_r0 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w1_r0 += w[1][ic] * FE5_C0_F_Q2[facet_0][iq][ic];
        double w2_r1 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w2_r1 += w[2][ic + 3] * FE5_C0_F_Q2[facet_1][iq][ic];
        alignas(32) double sv2[11];
        sv2[0] = (1.0 + -1 * (w2_r0 <= -1.09051254089422 * w1_r0 ? 1.0 : 0.0)) * w1_r0;
        sv2[1] = -0.917 * (w2_r0 <= -1.09051254089422 * w1_r0 ? 1.0 : 0.0) * w2_r0;
        sv2[2] = sv2[0] + sv2[1];
        sv2[3] = -1 * (1.09051254089422 * std::pow(std::min(sv2[2], 0.0), 2)) + std::pow(w2_r0, 2);
        sv2[4] = 4497.885 * sv2[3] * sp[17];
        sv2[5] = 4497.885 * sv2[3] * sp[18];
        sv2[6] = -1 * (w2_r1 > 0.0 ? 2.0 : 0.0) + (w2_r0 > 0.0 ? 2.0 : 0.0);
        sv2[7] = sv2[6] * sv2[4];
        sv2[8] = sv2[6] * sv2[5];
        sv2[9] = -1 * sv2[7] * sp[28];
        sv2[10] = -1 * sv2[8] * sp[28];
        const double fw0 = sv2[10] * weights2[iq];
        for (int i = 0; i < 3; ++i)
            BF0[i] += fw0 * FE5_C0_F_Q2[facet_0][iq][i];
        const double fw1 = sv2[9] * weights2[iq];
        for (int i = 0; i < 3; ++i)
            BF1[i] += fw1 * FE5_C0_F_Q2[facet_0][iq][i];
    }
    std::fill(&A[0], &A[12], 0.0);
    for (int i = 0; i < 3; ++i)
        A[i] += BF0[i];
    for (int i = 0; i < 3; ++i)
        A[i + 3] += BF1[i];
}

extern "C" DLL_EXPORT ufc::interior_facet_integral * create_ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_interior_facet_integral_main_otherwise()
{
  return new ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_interior_facet_integral_main_otherwise();
}


ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main() : ufc::form()
{
    // Do nothing
}

ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::~ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main()
{
    // Do nothing
}

const char * ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::signature() const
{
    return "64ffc63120c55f0dd378b05b31ac24129f146806683c95fe8bfd999e4ee7ab881f76de12ad04ec91eec4d0dccf345f9d3f9eda6328ec5195194b3b57b6e0f532";
}

std::size_t ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::rank() const
{
    return 1;
}

std::size_t ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::num_coefficients() const
{
    return 5;
}

std::size_t ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::original_coefficient_position(std::size_t i) const
{
    static const std::vector<std::size_t> position({0, 1, 2, 3, 4});
    return position[i];
}

ufc::finite_element * ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::create_coordinate_finite_element() const
{
    return create_ffc_element_6c16acd7c1e5c03c02e3b8ba4005fcbee12bfae2_finite_element_main();
}

ufc::dofmap * ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::create_coordinate_dofmap() const
{
    return create_ffc_element_6c16acd7c1e5c03c02e3b8ba4005fcbee12bfae2_dofmap_main();
}

ufc::coordinate_mapping * ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::create_coordinate_mapping() const
{
    return nullptr;
}

ufc::finite_element * ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
      {
        return create_ffc_element_6c16acd7c1e5c03c02e3b8ba4005fcbee12bfae2_finite_element_main();
        break;
      }
    case 1:
      {
        return create_ffc_element_6c16acd7c1e5c03c02e3b8ba4005fcbee12bfae2_finite_element_main();
        break;
      }
    case 2:
      {
        return create_ffc_element_e70bc42904b37e5ca21a54f369f8d6678e3cd3c7_finite_element_main();
        break;
      }
    case 3:
      {
        return create_ffc_element_e70bc42904b37e5ca21a54f369f8d6678e3cd3c7_finite_element_main();
        break;
      }
    case 4:
      {
        return create_ffc_element_e70bc42904b37e5ca21a54f369f8d6678e3cd3c7_finite_element_main();
        break;
      }
    case 5:
      {
        return create_ffc_element_e70bc42904b37e5ca21a54f369f8d6678e3cd3c7_finite_element_main();
        break;
      }
    }
    
    return 0;
}

ufc::dofmap * ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
      {
        return create_ffc_element_6c16acd7c1e5c03c02e3b8ba4005fcbee12bfae2_dofmap_main();
        break;
      }
    case 1:
      {
        return create_ffc_element_6c16acd7c1e5c03c02e3b8ba4005fcbee12bfae2_dofmap_main();
        break;
      }
    case 2:
      {
        return create_ffc_element_e70bc42904b37e5ca21a54f369f8d6678e3cd3c7_dofmap_main();
        break;
      }
    case 3:
      {
        return create_ffc_element_e70bc42904b37e5ca21a54f369f8d6678e3cd3c7_dofmap_main();
        break;
      }
    case 4:
      {
        return create_ffc_element_e70bc42904b37e5ca21a54f369f8d6678e3cd3c7_dofmap_main();
        break;
      }
    case 5:
      {
        return create_ffc_element_e70bc42904b37e5ca21a54f369f8d6678e3cd3c7_dofmap_main();
        break;
      }
    }
    
    return 0;
}

std::size_t ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::max_cell_subdomain_id() const
{
    return 3;
}

std::size_t ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::max_overlap_subdomain_id() const
{
    return 0;
}

bool ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::has_cell_integrals() const
{
    return true;
}

bool ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::has_exterior_facet_integrals() const
{
    return false;
}

bool ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::has_interior_facet_integrals() const
{
    return true;
}

bool ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::has_vertex_integrals() const
{
    return false;
}

bool ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::has_custom_integrals() const
{
    return false;
}

bool ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::has_cutcell_integrals() const
{
    return false;
}

bool ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::has_interface_integrals() const
{
    return false;
}

bool ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::create_cell_integral(std::size_t subdomain_id) const
{
    switch (subdomain_id)
    {
    case 1:
      {
        return new ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_cell_integral_main_1();
        break;
      }
    case 2:
      {
        return new ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_cell_integral_main_2();
        break;
      }
    }
    
    return 0;
}

ufc::exterior_facet_integral * ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return 0;
}

ufc::interior_facet_integral * ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return 0;
}

ufc::vertex_integral * ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::create_vertex_integral(std::size_t subdomain_id) const
{
    return 0;
}

ufc::custom_integral * ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::create_custom_integral(std::size_t subdomain_id) const
{
    return 0;
}

ufc::cutcell_integral * ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::create_cutcell_integral(std::size_t subdomain_id) const
{
    return 0;
}

ufc::interface_integral * ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::create_interface_integral(std::size_t subdomain_id) const
{
    return 0;
}

ufc::overlap_integral * ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::create_overlap_integral(std::size_t subdomain_id) const
{
    return 0;
}

ufc::cell_integral * ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::create_default_cell_integral() const
{
    return 0;
}

ufc::exterior_facet_integral * ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::create_default_exterior_facet_integral() const
{
    return 0;
}

ufc::interior_facet_integral * ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::create_default_interior_facet_integral() const
{
    return new ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_interior_facet_integral_main_otherwise();
}

ufc::vertex_integral * ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::create_default_vertex_integral() const
{
    return 0;
}

ufc::custom_integral * ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::create_default_custom_integral() const
{
    return 0;
}

ufc::cutcell_integral * ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::create_default_cutcell_integral() const
{
    return 0;
}

ufc::interface_integral * ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::create_default_interface_integral() const
{
    return 0;
}

ufc::overlap_integral * ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main::create_default_overlap_integral() const
{
    return 0;
}

extern "C" DLL_EXPORT ufc::form * create_ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main()
{
  return new ffc_form_8221eec8f3306f267b2ea4140156de2df9ffa419_form_main();
}

