\documentclass[11pt, reqno, nocenter]{article}


\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}                   % ... or a4paper or a5paper or ... 
%\geometry{landscape}                % Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{amsmath}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Rho}{\mathrm{P}}
\usepackage{hyperref}
\usepackage{parskip}
\usepackage{spverbatim}
\usepackage{dirtree}
\usepackage{bm}
\usepackage{siunitx}

\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}
\DeclareSIUnit\year{yr}


\title{Fenics Ice Sheet Model User Guide}
%\date{}                                           % Activate to display a given date or no date

\begin{document}

\maketitle

This document briefly outlines how to get started with the Fenics ice sheet model. 

\tableofcontents 
\section{Installation}

The ice sheet mdoel is built using the open source Python finite element software Fenics, and depends on the package tlm-adjoint for implementing inversion and error propagation capabilities. The simplest way to install Fenics and tlm-adjoint is to create a conda environment. 

\subsection{Installing Fenics}
 
1. Install Anaconda. This can be either Anaconda itself, or miniconda, which is a stripped down version. Ensure the Python version is greater than 3.6. Installer can be found here: https://www.anaconda.com/distribution/ 

2. Add the conda-forge channel. \\
conda config --add channels conda-forge \\
conda config --set channel\_priority strict

3. Create a new conda environment. \\
conda create -n fenics -c conda-forge fenics fenics-dijitso fenics-dolfin fenics-ffc fenics-fiat fenics-libdolfin fenics-ufl

4. Enter the conda environment: \\
source activate fenics

5. Make sure the pip package manager is up to date: \\
pip install -{}-upgrade pip

6. Install the following packages: \\
conda install matplotlib numpy ipython scipy 

7. Install hdf5 for python: \\
\url{http://docs.h5py.org/en/latest/index.html} \\
pip install h5py

8. Install pyrevolve: \\
\url{https://github.com/opesci/pyrevolve}

Change to directory where you would like to download pyrevolve to. You can delete the pyrevolve directory after finishing this step. \\ \\
git clone \url{https://github.com/opesci/pyrevolve.git} \\
cd pyrevolve/ \\
python setup.py install

9. Install mpi4py: \\
\url{http://mpi4py.scipy.org/docs/} \\
pip install mpi4py

10. To enter this environment: \\
source activate fenics

11. To exit: \\
source deactivate fenics

\subsection{Installing tlm\_adjoint}

1. Clone the git repository to the local drive where you want it to live:\\
git clone \url{https://github.com/jrmaddison/tlm_adjoint.git}

\subsection{Installing Fenics Ice}

1. Clone the git repository to the local drive where you want it to live: \\
git clone \url{https://github.com/cpk26/fenics_ice.git}


\subsection{Creating environment variables}
Create an environment variable storing the fenics\_ice base directory by adding the following to .bashrc, amending the path appropriately for your system. \\
FENICS\_ICE\_BASE\_DIR="/XXXX/XXXX/XXXX/fenics\_ice" \\                                            
export FENICS\_ICE\_BASE\_DIR   


\subsection{Modifying the Python Path}

Modify the default paths python looks for modules to include tlm\_adjoint and fenics ice. Add to the end of .bashrc: \\
PYTHONPATH=\"\$\{PYTHONPATH\}:/PATH/TO/tlm\_adjoint/python:/PATH/TO/fenics\_ice/code\" \\
export PYTHONPATH

\section{Program structure}

\subsection{Directory Structure}

\dirtree{%
.1 fenics\_ice.
.2 code.
.3 model.py.
.3 solver.py.
.2 runs.
.3 process\_eigendec.py.
.3 run\_balancemeltrates.py.                                                                                              
.3 run\_eigendec.py.                                                                                                      
.3 run\_errorprop.py.                                                                                                      
.3 run\_forward.py.                                                                                                        
.3 run\_inv.py.                                                                                                  
.3 run\_invsigma.py.                                                                                                    
.3 run\_momsolve.py.
.2 scripts.
.3 ismipc.
.2 aux.
.3 gen\_ismipC\_domain.py.
.3 test\_domains.py.
.2 input.
.3 ismipc.
.2 output.
.3 ismipc.
}

\subsection{Overview}

The core of the ice sheet model is in two files: {\tt /code/model.py} and {\tt /code/solver.py}. These are utilized by the python scripts in the {\tt /runs} folder, which execute specific parts of a simulation. The python scripts there are generic to any simulation. Each new simulation then has its own primary folder in the {\tt /scripts} folder, with simple bash scripts which call program files in {\tt /runs} with specific parameters and data files.

The bash scripts in {\tt /scripts} are where parameters and data file locations are specified; these are bash simple wrapper scripts for calling python scripts in {\tt /runs}. The data and parameters are used by the program files in {\tt /runs} to create a model object (via a class defined in {\tt model.py}) and subsequently a solver object (via a class defined in {\tt solver.py}). The model object contains all the necessary data for a simulation, such as topography, constants, and velocity observations for inversions. The solver object contains the ice sheet physics/inversion code. The model object is passed as a parameter to your solver object. This object then allows you to solve the SSA equations on your domain, invert for basal drag or $B_{glen}$, and perform uncertainty quantification. The options of any python script in the {\tt /runs} folder can be viewed by typing 'python run\_xxx.py --help'.


The {\tt /aux} folder contains auxillary files; in here, the file {\tt gen\_ismipC\_domain.py} generates the ismipC domain,  based off definitions in {\tt test\_domains.py}. The {\tt /input} folder is where input files, such as topography and ice thickness, for specific simulations are located. Similarily, the {\tt /output} folder is where output is stored from specific simulations.

\section{Tutorial: A Walkthrough of IsmipC}

The Ice Sheet Model Intercomparison Project for Higher-Order ice sheet Models (ISMIP-HOM) provides a standardized set of idealized tests for ice sheet models. In this walkthrough, we apply Fenics\_ice to the domain prescribed by experiment C (IsmipC). A description of IsmipC is provided in Section \ref{IsmipC} of this user guide. The original IsmipC is a static simulation, meaning time evolution is not considered. We'll extend it by running a dynamic simulation for the purposes of performing uncertainty quantification.


\subsection{Generating the Domain}

Navigate to the {\tt /fenics\_ice} base directory. Activate the fenics conda environment.

\begin{verbatim}
> source activate fenics 
\end{verbatim}

To begin, we'll generate the synthetic domain defined by the IsmipC experiment. The specifications are coded in the file {\tt /aux/test\_domains.py}. We'll use the python script 'gen\_ismipC\_domain.py' to create a domain with a given length and resolution.

\begin{verbatim}
> cd $FENICS_ICE_BASE_DIR/aux 
> python gen_ismipC_domain.py -o ../input/ismipC -L 40000 -nx 100 -ny 100 
\end{verbatim}

This will generate a square domain with side-length 40\si{\kilo\metre}, at resolution of 100 x 100, placing the output in the folder {\tt input/ismipc}.
Let's observe the files that are generated.

\begin{spverbatim}
> ls $FENICS_ICE_BASE_DIR/input/ismipC
B2.xml  Bglen.xml  alpha.xml  bed.xml  bmelt.xml  grid_data.npz  mask.xml  mesh.xml  smb.xml  thick.xml 
\end{spverbatim}

The .xml files contain discretized scalar fields over the IsmipC domain on a FEniCS mesh. The extension .npz indicates a numpy file format, and contains the domain resolution and length.

\begin{itemize}
\item B2.xml -- $\beta^2$ coefficient for linear sliding law $(\bm{\tau_b} = \beta^2 \bm{u})$;
\item  Bglen.xml -- parameter in Glen's flow law
\item alpha.xml -- variable in sliding law 
\item bed.xml -- basal topography
\item bmelt.xml -- basal melt. 
\item mask.xml -- mask of our domain
\item mesh.xml -- FEniCS mesh
\item smb.xml -- surface mass balance
\item thick.xml -- ice thickness

\end{itemize}

\subsection{Solving the Momentum Equations}

Having generated the files which describe our domain, we can solve the SSA momentum equations to determine ice velocities. 

\begin{spverbatim}
> cd $FENICS_ICE_BASE_DIR/scripts/ismipc/ 
> ./forward_solve.sh

Generating new mesh                                                                                                                                              
Building point search tree to accelerate distance queries.                                                                                                       
Computed bounding box tree with 39999 nodes for 20000 points.                                                                                                    
Solving nonlinear variational problem.                                                                                                                             
Newton iteration 0: r (abs) = 1.585e+03 (tol = 1.000e-08) r (rel) = 1.000e+00 (tol = 5.000e-02)                                                                 
Newton iteration 1: r (abs) = 1.139e+02 (tol = 1.000e-08) r (rel) = 7.186e-02 (tol = 5.000e-02)                                                                 
Newton iteration 2: r (abs) = 1.307e+02 (tol = 1.000e-08) r (rel) = 8.248e-02 (tol = 5.000e-02)                                                                  
Newton iteration 3: r (abs) = 9.443e+01 (tol = 1.000e-08) r (rel) = 5.958e-02 (tol = 5.000e-02)                                                                  
Newton iteration 4: r (abs) = 5.682e+01 (tol = 1.000e-08) r (rel) = 3.585e-02 (tol = 5.000e-02)                                                                 
Newton solver finished in 5 iterations and 5 linear solver iterations.                                                                                         
Solving nonlinear variational problem.                                                                                                                          
Newton iteration 0: r (abs) = 6.650e+01 (tol = 1.000e-05) r (rel) = 1.000e+00 (tol = 1.000e-05)                                                                 
Newton iteration 1: r (abs) = 4.913e+00 (tol = 1.000e-05) r (rel) = 7.387e-02 (tol = 1.000e-05)                                                                  
Newton iteration 2: r (abs) = 4.393e-02 (tol = 1.000e-05) r (rel) = 6.606e-04 (tol = 1.000e-05)                                                                 
Newton iteration 3: r (abs) = 5.647e-06 (tol = 1.000e-05) r (rel) = 8.492e-08 (tol = 1.000e-05)                                                                 
Newton solver finished in 4 iterations and 4 linear solver iterations.                                                                                           
Time for solve: 4.667648553848267      

ls $FENICS_ICE_BASE_DIR/input/ismipC/momsolve
...
\end{spverbatim}

The script automatically places the output in the subdirectory of {\tt input/} since we'll use the velocities we solved for in the next step, generating synthetic observations.

Opening {\tt forward\_solve.sh} with any text editor, we can confirm that this is a simple wrapper script.

\begin{spverbatim}
#!/bin/bash
set -e

BASE_DIR=$FENICS_ICE_BASE_DIR
RUN_DIR=$BASE_DIR/runs

INPUT_DIR=$BASE_DIR/input/ismipC
OUTPUT_DIR=$INPUT_DIR/momsolve

cd $RUN_DIR

python run_momsolve.py -b -q 0 -d $INPUT_DIR -o $OUTPUT_DIR
\end{spverbatim}

The bash script specifies key folders, that we are solving momentum equations on a domain with periodic boundary conditions (-b option), and that we are using a linear sliding law (-q 0).

\subsection{Generating Synthetic Observations}

IsmipC is a synthetic experiment, meaning we don't have observational data of ice velocities. We can generate pseudo-oberservations by adding gaussian noise to the solved velocities. We'll assume the noise is additive rather than a multiplicative factor. 

The python script 'Uobs\_from\_momsolve.py' takes the vector field in U.xml and generates the files: vel\_mask.xml, u\_obs.xml, v\_obs.xml, u\_std.xml, and v\_std.xml. The first file identifies where velocity data is available, the next two files contain the pseudo-observations in the x and y directions, with the final two files containing the standard deviation of the gaussian noise applied. 

\begin{spverbatim}
> cd $FENICS_ICE_BASE_DIR/aux/
> python Uobs_from_momsolve.py -b -L 40000 \
-d $FENICS_ICE_BASE_DIR/input/ismipC/momsolve
> find $FENICS_ICE_BASE_DIR/input/ismipC/momsolve \
-type f -regex '.*\(obs\|std\).xml'
/mnt/c/Users/ckozi/Documents/Python/fenics/fenics_ice/input/ismipC/u_obs.xml
/mnt/c/Users/ckozi/Documents/Python/fenics/fenics_ice/input/ismipC/u_std.xml
/mnt/c/Users/ckozi/Documents/Python/fenics/fenics_ice/input/ismipC/v_obs.xml
/mnt/c/Users/ckozi/Documents/Python/fenics/fenics_ice/input/ismipC/v_std.xml
\end{spverbatim}

Copy the five files generated into {\tt \$FENICS\_ICE\_BASE\_DIR/input/ismipC/}. A study site in Antarctica or Greenland would require generating these files (except mesh.xml) from a surface velocity dataset such as NSIDC MEaSUREs.

\begin{verbatim}
> cd $FENICS_ICE_BASE_DIR/input/ismipC/momsolve
> cp mask_vel.xml u_*.xml v_*.xml ..
\end{verbatim}

\subsection{Uncertainty Quantification}

Fenics-ice is developed with a view of understanding uncertainty in ice sheet models. Because inversions for key ice-sheet model variables (basal drag and $B_{glen}$) solve under-determined systems of equations, the solutions may have large, and spatially varying error distributions. The novel capabality of fenics-ice is to propogate this uncertainty through a forward stepping simulation, allowing us to calculate the probability distribution of a quantity-of-interest through time, rather than a point estimate. 

The bash scripts starting with the prefix 'uq\_' in {\tt scripts/ismipc} perform the uncertainty quantification process. The suffixes relate to various values of parameters. Uncertainty quantification can be seperated into four parts, corresponding to to different python scripts in the {\tt runs/} folder.

Beyond the specification of parameters and data sources, the uncertainty quantification scripts call the following (in order):

\begin{enumerate}
	\item {\tt run\_inv.py} -- Invert for basal drag
	\item {\tt run\_forward.py} -- Timestep the simulation forward in time
	\item {\tt run\_eigendec.py} -- Run the eigen-decomposition of the Hessian Matrix -- allowing us to multiply by the inverse of the covariance matrix of basal drag.
	\item {\tt run\_errorprop.py} -- Run the errorpropogation code to calculate the uncertainty in a quantity of interest through time arising from uncertainty in the inverted values of basal drag
\end{enumerate}


Steps (2) and (3) are independent of each other, and only depend on step (1). Hence their order can be switched.

There are five scripts pertaining to uncertainty quantification in {\tt scripts/imsipc/}.
\begin{enumerate}
	\item {\tt uq\_rc\_1e4.sh  }
	\item {\tt uq\_rc\_1e6.sh}
	\item {\tt uq\_30x30.sh  }
	\item {\tt uq\_40x40.sh  }
	\item {\tt run\_all.sh}  
\end{enumerate}

The first two bash scripts specify simulations with different levels of regularization for the inversion. Script {\tt uq\_rc\_1e4.sh} has less regularziation and results in high frequency features in basal drag. The script {\tt uq\_rc\_1e4.sh} increases the level of regularization by two orders of magnitude, so that the inverted basal drag field mirrors the specification by IsmipC. Grid resolution is the focus of the next two scripts. The scripts {\tt uq\_30x30.sh} and {\tt uq\_40x40.sh} use the regulariztion of simulation {\tt uq\_rc\_1e6.sh}, but increase the resolution to 30x30 and 40x40 respectively. The final script -- {\tt run\_all.sh}  -- simply runs the other four scripts.

We'll proceed with script {\tt uq\_rc\_1e6.sh}. To run uncertainty quantification of IsmipC, simply call the bash script:
\begin{verbatim}
> cd $FENICS_ICE_BASE_DIR/scripts/ismipc/
> ./uq_rc_1e6.sh
...
\end{verbatim}

There will be a significant amount of output. 

On a Dell XPS laptop with Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz and 32GB of RAM, running Python via the Windows 10 Linux Subsystem (WSL v1.0) the script had the following timings:   

real	\hspace{10mm} 8m27.972s \\
user  \hspace{9mm}  32m10.906s \\
sys    \hspace{11mm} 21m14.797s. \\

These can be obtained in linux shell by executing {\tt time ./uq\_rc\_1e6.sh}. Let's break down the contents of the {\tt uq\_rc\_1e6.sh} script.

The script begins by defining the locations of inputs and outputs.

\begin{spverbatim}
BASE_DIR=$FENICS_ICE_BASE_DIR
RUN_DIR=$BASE_DIR/runs

INPUT_DIR=$BASE_DIR/input/ismipC
OUTPUT_DIR=$BASE_DIR/output/ismipC/ismipC_inv6_perbc_20x20_gnhep_prior
EIGENDECOMP_DIR=$OUTPUT_DIR/run_forward
FORWARD_DIR=$OUTPUT_DIR/run_forward

EIGFILE=slepceig_all.p
\end{spverbatim}

The variable {\tt OUTPUT\_DIR} should be unique to this specific simulation. The other directories are standard and do not need to be modified. The variable {\tt EIGFILE} specifies the name of the file where the output of eigendecomposition is stored. 

The current name reflects the fact that the eigenvalues and eigenvectors where calculated using the library SLEPc, and that all eigenvectors/values where calculated. Future releases plan to offer additional libraries to solve the eigenvalue problem. For large domains, calculating all eigenvectors/values is not necessary, nor feasible. 

Next in the script we define the values of parameters that will be used as command line arguments. These will be discussed in the context of the python script they're applicable to.
\begin{spverbatim}
RC1=1.0
RC2=1e-2
RC3=1e-2
RC4=1e6
RC5=1e6

T=30.0
N=120
S=5

NX=20
NY=20

QOI=1
\end{spverbatim}

The core of the script are the following lines. To see a complete list of options for each of the these python scripts, execute them with the '--help' flag (e.g. {\tt python run\_inv.py --help}).


\begin{spverbatim}
cd $RUN_DIR

python run_inv.py -b -x $NX -y $NY -m 200 -p 0  -r $RC1 $RC2 $RC3 $RC4 $RC5 -d $INPUT_DIR -o $OUTPUT_DIR
python run_forward.py -t $T -n $N -s $S -i $QOI -d $OUTPUT_DIR -o $FORWARD_DIR
python run_eigendec.py -s -m -p 0   -d $OUTPUT_DIR -o $EIGENDECOMP_DIR -f $EIGFILE
python run_errorprop.py -p 0 -d $FORWARD_DIR -e $EIGENDECOMP_DIR -l $EIGFILE -o $FORWARD_DIR
\end{spverbatim}

The first python script {\tt run\_inv.py} performs the inversion. The {\tt -b} flag indicates that periodic boundary conditions should be applied at the domain boundary. Currently periodic boundary conditions cannot be specified on individual boundaries, but rather for the entire domain . Each of {\tt -x} and {\tt -y} specify the resolution in the number of cells in the x and y directions. At the present stage, resolution needs to be uniform in both axis. The {\tt -m} option specifies that a maximum of 200 iterations of gradient descent be performed to minimize the cost-function, while the input {-p 0} indicates we are optimizing basal drag. In the case of IsmipC, $B_{glen}$ is assigned a constant value. Scaling constants in the cost function for the inversion are specified by the {\tt -r} option. The first value scales the velocity misfit, RC2 and RC4 apply to the regularization of alpha, RC3 and RC5 apply to the regularization of beta. RC2 and RC3 specify the delta parameters in the cost function, and RC4 and RC5 specify the gamma parameters. The options {\tt -d} and {\tt -o} specify input and output directoies.

The second python script {\tt run\_forward.py} numerically integrates the simulation forward in time and calculates the adjoint of the quantity of interest with respect to the specified variable. The {\tt -t} option determines the number years to run the simulation for, with {\tt -n} number of timesteps. The $-s$ parameter specifies the numer of sensitivities to calculate. If the value is 1, than the sensitivity at the last timestep is calculated. Otherwise they are calculated at np.linspace(0, run\_length, number\_of\_sensitivites). The sensitivities of a quantity of interest are calculated. Here, we specify the quantity of interest as the integral of the height squared with the {\tt -i 1} option, as the IsmipC simulation is mass-conserving due to the periodic-boundary conditions. The other available option, suitable to real life domains, is volume above floation. Again, the options {\tt -d} and {\tt -o} specify input and output directories.

The third python script {\tt run\_eigendec.py} eigendecomposes the Hessian of the inversion cost function. The {\tt -s} flag specifies that the SLEPc library should be used, presently the only functioning option. To consider only the velocity misfit portion of the cost function, we set the {\tt -m} flag. As for {\tt run\_inv.py}, we set {\tt -p 0} to consider only basal drag. The remaining options specify the input and output locations. 

Lastly, the fourth python script {\tt run\_errorprop.py} assembles the output of {\tt run\_forward.py} and {\tt run\_errorprop.py} to determine the standard deviation of the quantity of interest through time. The options for this script duplicate those above.

\subsection{Plotting}

This section will go through plotting the results of the IsmipC experiments. It assumes you ran all the simulations in {\tt ismipc/scripts/}. If not, you'll need to execute {\tt run\_all.sh} in that folder. The timings on the same machine as previously are:

real    \hspace{10mm}79m31.631s         \\                                                                                            
user   \hspace{8mm} 350m12.844s      \\                                                                                               
sys     \hspace{11mm}215m26.250s    \\

\subsubsection{Inversion Results}
The first plot we'll create will allow us to examine the inversion results. We'll do this by running the python script {\tt plot\_inv\_results.py}. You can modify the simulation and output location at the top of the script. The default simulation is {\tt uq\_rc\_1e6} and the default output location is a the folder {\tt \$FENICS\_ICE\_BASE\_DIR/output/ismipC/uq\_rc\_1e6/plots}. The script will create the a file named {\tt inv\_results.pdf} there.

\begin{spverbatim}
>cd $FENICS_ICE_BASE_DIR/output/ismipC/
>python plot_inv_results.py
\end{spverbatim}

There are size panels in the output plot.




\section{IsmipC}\label{IsmipC}
Ice Sheet Model Intercomparison Project for Higher-Order ice sheet Models (ISMIP-HOM) is a set of standardized simulations used in the glaciology community for model intercomparison. Due to its familiarity, and simple setup, Experiment C was selected for the tutorial in this user-guide. It allows many aspects of uncertainty quantification to be explored in a simple domain.

The domain of Experiment C is a square domain with periodic boundary conditions on all four boundaries. The surface and basal topography are prescribed as:

%
\begin{equation}
s(x,y) = -x \cdot tan(0.1\si{\degree})
\label{eq:ismipCS}
\end{equation} 
%
\begin{equation}
b(x,y) = s(x,y) - 1000
\label{eq:ismipCB}
\end{equation} 
%


In Experiment C, basal drag is parameterized with a linear sliding law, with the drag coefficient prescribed as:
%
\begin{equation}
\beta = [1000 + 1000sin(\omega x)cos(\omega y)] \cdot t_y^{-1}
\label{eq:ismipCBD}
\end{equation} 
%
where $t_y$ is the number of seconds in a year, converting $\beta$ to SI units.



\begin{table}[]
\centering
\begin{tabular}{llll}
\hline
 Symbol & Constant  & Value  & Units   \\
 \hline
 A &  Ice-flow parameter &  $10^{-16}$ &  \si{\pascal\tothe{n}\per\year}  \\
 $\rho_i$ & Ice Density &  910 &   \si{\kilo\gram\per\metre\cubed}   \\
  g & Gravitational constant  & 9.81  & \si{\metre\per\second\squared}   \\
  n & Exponent in Glen's Flow law  & 3  &   \\
  $t_y$ & Seconds per year  & 31556926  & \si{\second\per\year}   \\
 \hline
\end{tabular}
\caption[Constants for ISMIP-HOM experiments.]{Constants for ISMIP-HOM experiments}
    \label{table:ISMIPparam}
\end{table}




\end{document}  